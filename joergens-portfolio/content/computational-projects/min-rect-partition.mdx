---
title: "Minimum Rectangular Partitioning" 
---
# **Description** 
Given any orthogonal polygon, this model calculates the minimum number of rectangles required to partition the input polygon and generates every permutation of the tiling. In geometry, to “tile” means to cover without gaps or overlaps, to build up a shape from building blocks. “Partitioning” refers to dividing a space into non-overlapping regions, decomposing a complex shape into simpler building blocks. Here, the two terms are used interchangeably. 

The input polygon can be x-convex, y-convex, both, or neither and may contain any number of orthogonal, polygonal holes. The algorithm first performs degenerate decomposition. Every pair of co-grid concave vertices (vertices having an inner angle of 270° and sharing a horizontal or vertical coordinate) is identified. By constructing chords which connect these pairs, the object can be partitioned into subpolygons. For minimum partitioning, L. Ferrari et al. proved that the optimal selection maximizes the number of nonintersecting chords. 

This can be found by transforming the decomposition problem into a graph partitioning problem where nodes represent chords and edges are drawn for chord intersections. Because horizontal chords can only intersect vertical chords, the resulting graph is bipartite. 

Under degenerate decomposition, the algorithm searches for all maximal independent sets, which are sets containing the maximum number of disconnected nodes. Each set will yield a different partitioning but will have the same maximal number of non-degenerate subpolygons. 

The second part of the algorithm loops through each concave vertex (now non-degenerate by preparation) and, to further subdivide the polygon, draws a chord between that vertex and the boundary of the polygon. This process is sequential, and every concave vertex is visited once. Different orderings can yield different partitions, but they will all be of the same minimum number. At the end, another set of graphs gets generated where each node is a tile and edges are drawn between neighbors. To display the partitions in a legible way, a greedy coloring of the neighbor graph ensures that no adjacent rectangles are rendered with the same color. 

# **Context**
I bumped into this problem accidentally as I was developing a parametric model of a cross-laminated timber housing typology. That project began while I was working as a woodworker at a furniture factory in Chicago. I picked it back up with a vague notion of adding the model to a personal portfolio. To get it portfolio ready, I not only wanted to clean things up but also add some flashy features for the sole purpose of showing off my coding/design skills to potential employers. That is what a personal portfolio is all about after all. One of the flashy features I wanted to add to the model was a floorplan designer. 

The CLT typology I developed my model for was based on Paul Mayencourt’s floor-cassette system which worked well on rectangular floorplans with parameterized length and width. Paul was on as a consultant at the furniture company while I was there. On a rectangular floorplan, that system can be laid out in a simple grid, but when you create a more complex shape (an ‘L’, say, or a building with a courtyard) that same grid layout may not apply. If this had been a practical undertaking or if I had imposed a stricter deadline on myself, there are constraints to be applied and compromises to be made that would force a grid layout to work. For example, we could constrain the dimensions of all wall segments to be multiples of the cassette’s dimensions, or we could allow some grids to be “cropped” on one side. That would increase building-material waste but only marginally. 

I decided not to impose a deadline nor concern myself with current practices. Paul designed his system to optimize material usage, which I did not want to compromise. Nor did I want to constrain input dimensions since I was already constraining floorplan silhouettes to be orthogonal. As discussed, this can lead to a misalignment of grid layouts. I had some ideas of how to fix those problems, but I figured that minimizing the number of common edges would be a good place to start. I effectively cornered myself into asking “What is the minimum number of grids needed to tile this floorplan?” 

When I began with a few naïve attempts to answer that question I hadn’t fully constructed the question yet. When those attempts failed, I had to turn to the literature. To generate architectural floorplans, I certainly hadn’t anticipated needing to teach myself graph theory or adapting algorithms from image compression and integrated circuit design. Needs must, I guess. In the model above, I’ve deliberately rendered the output to block out the volume so that partitions (floorplans) can be judged from different angles. 

# **How It Works**
Input and output data are both handled in Three.js. When the user applies a partitioning to an input shape, the data is processed by Python scripts running on AWS Lambda with layer dependencies. Everything is contained to the Lambda function apart from one call which is made to a Rhino.Compute server hosted on a virtual machine (AWS EC2 instance) to compute input area properties. 

# **Next Steps**
I am currently working on integrating this model as a floorplan designer for my CLT building model. 

In the process of reading papers and learning about minimum partitioning, I began to develop a new algorithm for minimum $$k$$ partitioning, which is the extension of the special case above where $$k=4$$ to cases where $$k$$ can be any even number of vertices. I need to test the algorithm more extensively, but in terms of time complexity it has so far outperformed the algorithms I’m aware of. 
