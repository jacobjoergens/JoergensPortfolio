---
title: "Minimum Rectangular Partitioning" 
---
# **Description** 
This model generates every permutation of the minimum rectangular tiling of a given orthogonal polygon. The input can be x-convex, y-convex, both, or neither and may contain any number of orthogonal, polygonal holes. Just to clarify some notation, “tiling” refers to the composition of a complex shape from basic building blocks and “partitioning” refers to the decomposition of a complex shape into basic building blocks. In this case, we can use the two terms interchangeably because the building blocks in both cases are rectangles. 

To find the minimum partitioning, I adapted a graph-based decomposition algorithm. The first part of this algorithm performs degenerate decomposition and works as follows. Every pair of co-grid concave vertices (vertices having an inner angle of 270° and sharing a horizontal or vertical coordinate) is compiled into a list. The idea here is to construct chords between co-grid vertices that partition the input polygon into non-degenerate subpolygons (i.e., polygons containing no co-grid vertices). [L. Ferrari et al.]( https://www.sciencedirect.com/science/article/pii/0734189X84901397) proved that the optimal selection of co-grid pairs is that which maximizes the number of nonintersecting chords. 

In practice, this is most easily accomplished by transforming the decomposition problem into a graph partitioning problem. My implementation uses the NetworkX python package to construct a bipartite graph where nodes represent either horizontal or vertical chords and edges represent intersections. The algorithm then searches for every maximal independent set. Each of these sets contains the same maximum number of disconnected nodes but represents a unique arrangement of non-degenerate subpolygons. 

The second part of the algorithm loops through each concave vertex within a maximal set (now non-degenerate by preparation) and further subdivides the polygon by drawing either a horizontal or a vertical chord between that vertex and the polygon’s boundary. This process is sequential, every concave vertex within a single partitioning is visited once. The number of permutations is equal to $$2^n$$ where $$n$$ is the number of concave vertices remaining after degenerate decomposition. 

At the end, I generate a graph for each partition where nodes represent tiles and edges are drawn between adjacent tiles. To display the partitions in a legible way, I use a greedy coloring algorithm to ensure that no neighboring rectangles are rendered with the same color. 

# **Context**
I bumped into this problem accidentally while I was working at a furniture company in Chicago where I had nominally been hired to help the company transition from building furniture to building cross-laminated timber (CLT) housing. In practice, 95% of the time I worked on the shop floor as a woodworker but in the 5% left over, I was tasked with coding a parametric model for a CLT housing typology. The specific typology I used was based on a [floor-cassette system]( https://paulmayencourt.com/lowcarbon-timber-design ) developed by Paul Mayencourt who was consulting remotely on the CLT (non)transition. In one week, while the boss was away, I began coding the model and got it to a presentable place. 

I never got another reprieve from manual work after that, but after leaving the company, I picked up where I had left off. To get the CLT model to a place where I could add it to this website, I not only wanted to clean it up but also add some flashy features for the sole purpose of showing off my coding/design skills to potential employers. That is what a personal portfolio is all about after all. One of the flashy features I wanted to add to the model was a floorplan designer. 

Paul’s floor-cassette system was designed be laid out in a simple grid on a rectangular floorplan, but when you create a more complex shape (an ‘L’, say, or a building with a courtyard) that same grid layout may not project neatly onto each subcomponent. In these cases, there are constraints and compromises that could force a grid layout to work. For example, we could constrain the dimensions of all wall segments to be multiples of the cassette’s dimensions, which would limit floorplans to grid cells. A different solution would be to add a stunted row/column to make up the remainder where the grid does not project neatly. That would increase building-material waste but only marginally. 

Paul designed his system to optimize material usage, which I decided I did not want to compromise. Nor did I want to further constrain input dimensions since I was already limiting floorplan silhouettes to be orthogonal for the time being. By refusing to make compromises listed above, I had to accept to the possibility of misaligned grids. While there are some creative methods to handle these misalignments with built-ins, windows or concealing walls, I figured that minimizing the number of common edges where these methods are employed would be a good place to start. I effectively cornered myself into asking “What is the minimum number of grids needed to tile this floorplan?” 

With my first naïve attempts, I hadn’t fully articulated the question yet so when those predictably failed, I turned to the literature. I hadn’t appreciated how complex of a question it was. To develop the model above, I read and adapted algorithms from papers dealing with image compression and integrated circuit design. In a nod to its original purpose of generating architectural floorplans, I intentionally designed the model's output to block out volumes, allowing partitions to be evaluated from various angles.

# **How It Works**
Input and output data are both handled in Three.js. When the user applies a partitioning to an input shape, the data is processed by Python scripts running on AWS Lambda with layer dependencies. Everything is contained to the Lambda function apart from one call which is made to a Rhino.Compute server hosted on a virtual machine (AWS EC2 instance) to compute input area properties. 

# **Next Steps**
I am currently working on integrating this model as a floorplan designer for my CLT building model. 

While reading papers and studying minimum partitioning, I devised a new minimum $$k$$ partitioning algorithm. Minimum $$k$$ partitioning is the extension of the special case above where $$k=4$$ to cases where $$k$$ can be any even number of vertices. I still need to test the algorithm, but so far it has outperformed other popular algorithms on time complexity. 
