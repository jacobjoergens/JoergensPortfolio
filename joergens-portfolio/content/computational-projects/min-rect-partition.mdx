---
title: "Minimum Rectangular Partitioning" 
---
# **Description** 
Given any orthogonal polygon, this model calculates the minimum number of rectangles required to partition the input polygon and generates every permutation of the tiling. To “tile” in math terms means to cover without gaps or overlaps, to build up a shape from building blocks. “Partitioning” refers to dividing a space into non-overlapping regions, decomposing a complex shape into simpler building blocks. Here, the two terms are used interchangeably. The input polygon can but need not be x or y convex and may have any number of orthogonal, polygonal holes. The algorithm first performs degenerate decomposition. Every pair of co-grid concave vertices (vertices having an inner angle of 270° and sharing a horizontal or vertical coordinate) is identified. By constructing chords which connect these pairs the object is partitioned into subpolygons. L. Ferrari et al. proved that the optimal selection when searching for a minimum partitioning is that which maximizes the number of nonintersecting chords. 
The optimal selection can be found by transforming the decomposition problem into a graph partitioning problem where nodes represent chords and edges are drawn for chord intersections. Because horizontal chords cannot intersect each other, and the same is true for vertical chords, the graph we construct is bipartite. 
Under degenerate decomposition, the algorithm searches for all maximal independent sets, which are sets containing the maximum number of disconnected nodes. Each set will yield a different partitioning but with the same maximal number of non-degenerate subpolygons. 
The second part of the algorithm loops through each concave vertex (now non-degenerate by preparation) and, to further subdivide the polygon, draws a chord between that vertex and the boundary of the polygon. This process is sequential, and every concave vertex is visited once. Different orderings can yield different partitions, but they will all be of the same minimum number. At the end, another set of graphs gets generated where each node is a tile and edges are drawn between neighbors. To display the partitions in a legible way, a greedy coloring of the neighbor graph ensures that no adjacent rectangles are rendered with the same color. 
# **Context**
I bumped into this problem as I was developing a parametric model of a cross-laminated timber housing typology. That project began while I was working as a woodworker at a furniture factory in Chicago. With a vague picture in my head of adding the model to a portfolio website, I not only wanted to clean up what was there but also add certain features. I freely admit that those features were intended to serve the sole purpose of showing off my coding/design skills to potential employers. That is, after all, what a personal portfolio is meant to do. One of the “flashy” features I wanted to add to the model was a floorplan designer. The model as it stood could only output rectangular floorplans with parameterized length and width. 
I eventually planned to allow diagonal and curved walls, but realized there was another problem I had to figure out first. The CLT typology I developed my model for was based on Paul Mayencourt’s floor-cassette system. I learned about that system from Paul who was on as a consultant at the furniture company I worked for in Chicago. On a rectangular floorplan that system can be laid out in a simple grid, but when you create a more complex shape (an ‘L’, say, or a rectangular building with a courtyard) that same grid layout may not apply. If this had been a practical undertaking or if I had imposed a stricter deadline on myself, there are constraints to be applied and compromises to be made that would force a grid layout to work. For example, we could constrain the dimensions of all wall segments to be multiples of the cassette’s dimensions, or we could allow some grids to be “cropped” on one side. That would increase building-material waste but only marginally. 
Thankfully, I did not self-impose a very strict deadline. CLT is a more sustainable building material than say steel, but it too has a carbon cost, not to mention a steep price tag. Paul designed his system to optimize material usage, which I did not want to compromise. Nor did I want to constrain input dimensions since, for the time being, I was already constraining floorplan silhouettes to be orthogonal. All orthogonal polygons can be subdivided into rectangles and, as I learned reading through literature, there are all kinds of simple-sounding questions you can ask. What is the optimal packing of a polygon given a tile of shape S? Which partitioning maximizes the area distribution of the partitions? As it turns out, the question I cornered myself into asking was “What is the minimum number of rectangles needed to tile this polygon?” Because my issues arose from the meeting of different grid layouts, I figured that minimizing the number of common edges would be a good place to start. 
My path to what you see above was anything but linear. When I began with a few naïve attempts I hadn’t fully constructed the question yet. Needless to say, those attempts failed, and I had to turn to the literature. At the start, I certainly hadn’t anticipated a crash course in graph theory or adapting algorithms from image compression and integrated circuit design to generate architectural floorplans.
# **Next Steps**
I am currently working to extend the algorithm described above to perform minimum k partitioning. It will then output the minimum number of k-vertex ($$k=4,6,8…$$) partitions as opposed to the special case now where $$k=4$$. Also to come is the parametric model of the CLT building typology because at this stage, this is still just a thought experiment. Nevertheless, I wanted to get it out there. I hope you find it interesting and, ifyou happen to be a potential employer, impressive. 
