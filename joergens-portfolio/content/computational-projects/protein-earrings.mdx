---
title: "Protein Earrings" 
---

# **Description**
I took an architecture course at the end of undergrad called “Complex Curves and Plastic Shapes,” which was split down the middle between theory and practice. The theory half was spent reading and discussing essays on and by artists—mainly sculptors. The other half was spent on design assignments in Rhino, a 3D modeling software. Over the course of the quarter, I became interested in the role of codes in art both on the theory level and the practice level. On the theoretical level, many of the artists we read explicitly referred to a set of rules endogenous to art which they argued should govern artmaking and our interpretation of it. You can read an adaptation of my final essay for that class [here](http://jacobjoergens.com/computational-design/sculptural-language) which muses in more depth about the emergent properties of these rule sets when viewed as codified languages. On the practical level, I started to see parallels to what I was teaching myself in Grasshopper—a plugin for Rhino which provides a programming environment to create models and explore design variations through definable parameters. 

In another example of the accidental interdisciplinarity I so benefited from [in high school](http://jacobjoergens.com/woodwork/sidetable), sprinkles of the other courses I was in: Multiscale Biological Modeling, Spanish, and the Science, History, Policy and Future of Water, were each mixed together in the blender of my head to get me to think of proteins in a sculptural sense.

Nearly every protein is made up of the same 22 proteinogenic amino acids. The standard genetic code (DNA, RNA, mRNA) encodes the sequence of twenty of these amino acids in proteins and the other two are incorporated through special translational mechanisms. Each amino acid within a protein is encoded, with some redundancy, by one out of 64 possible three letter sequences of nucleotides (A,G,C and T), fittingly known as codons. Across every scale of a protein’s existence, there is a readily definable vocabulary of building blocks whether at the level of nucleotides, codons, amino acids, or peptides. These combine according to their own grammatical structure. Biochemists generally refer to four structural scales: primary structure is specified by the amino acid sequence, secondary structures are local spatial conformations (α-helices, β-sheets, turns), tertiary structure describes how an entire protein folds into a 3-dimensional shape and quaternary structure is the spatial association with different proteins. 

At each scale, organizational rules govern and give rise to an object whose function is intimately tied to form. Although the artists Katarzyna Kobro, Georges Vantongerloo and Barbara Hepworth would argue over the specifics, they all see artistic form as being a product of one or another language-forming rule set. This project was an exploration into the ways that the following (and breaking) of codes informs art. Breaking the connection between a form and its underpinning code is sometimes the best method of proving the connection exists. In biology, this happens naturally through transcriptional errors, misfolding, or denaturing all of which divorce the proteins form from its underlying code. To study protein function and misfunction, biologists often recreate these breaking conditions. 

This model first takes as input the atom data of a protein. It thereby coopts an existing language, which, through the three primary structural scales, clearly connects the protein’s form to its underlying code. The default protein is the crystal structure of sOPH, a hydrolase found in microbes shown to have potential in breaking down PVA plastics. You can, however, search for any protein structure in the [RCSB database](https://www.rcsb.org/) by title to replace the default. 

The model is designed to then break the protein’s form-code connection, in this case not by mimicking actual biological processes but by introducing a new, visual vocabulary and grammatical structure. Proteins allowed me to start from a point of a well established 3-dimensional language. By deliberately breaking that language with a new rule-based system to create these earrings, I hoped to understand in greater, empathetic depth the role of linguistics in art as described by Kobro, Vantongerloo and Hepworth. The following was the central figure of my final practical project for Geoff Goldberg’s class. It captures and compares 9 instances of this language in use; three different protein structures are pronounced using three distinct parameter sets. 

<Figure src="/images/sculptural-language/final-project-3x3.png" width="718" height="404" caption="Rows (top to bottom): Cobra Nerve Growth Factor, Ubiquitin, and Covid-19 viral protein." alt="Figure 5"/> 

The protein data this model receives comes in the form of atom position. Metaball point charges, which are essentially spheres that can meld together when close in proximity, are placed at each position. This forms the base vocabulary. The radius parameter changes the size of the spheres used. The remaining inputs together form a grammar which governs the combination of these sculptural components. Parameterization allows you to create statements using the resulting language. 

## **Trim Tolerance:** 
### Proteins are made of thousands of atoms which are, by definition, very close to one another. The model imposes a rule to trim neighboring atoms from the input data that fall within a certain distance. This parameter sets the distance or tolerance used to filter out neighbors. A higher value trims a greater number of atoms from the input data and a lower value maintains a greater number of atoms. 

## **Charge Strength:** 
### Charge strength determines the distance over which metaball charges interact. A higher value means that metaballs will meld into a single, contiguous object at greater distances. A lower value will preserve the spherical shape of metaballs in closer proximity. 

## **Smoothing Passes:** 
### The metaball point charges are wrapped in marching cubes to create a mesh. This parameter sets the number of times to run the Laplacian smoothing algorithm on polygonal meshes. A higher value yields a smoother object. A lower value preserves more of the topological features that come from the metaball charges. 

## **Scale:** 
### Changes the size of the earring hook

There are other, hidden parameters that also feed in to the model’s grammatical structure. I’ve decided not to include these in the user interface for one of three reasons. The first is to try to limit artifacts. Similar to what can happen in real protein synthesis, the grammatical structure of this model is blind to input. Whereas in nature, genetic mutations might yield protein variants that take on new, unexpected functions possibly associated with disease, this model’s grammar will output mutant forms (e.g. 2D shards, disjoint volumes) if fed a particular mix of inputs. There are hundreds of thousands of protein structures on the RCSB Protein Data Bank. The user facing parameters listed above add thousands more to the total number of possible inputs. On top of constraining certain maximum and minimum values, I've added rules like filtering out everything but the largest mesh. I've also set some hidden parameters like target iso value and marching cube size in an attempt to limit artifact generation. The second reason I had to limit parameters in the user interface was to keep things simple. There is quite a lot to take in and the parameter space already provides a dizzying number of possible combinations to explore. The third reason was to keep things running quickly. Some of these algorithms (marching cubes and mesh refinement in particular) can become remarkably expensive from a computational standpoint. To keep the language fluent, I decided to hide parameters that might cost more than a second. 

# **Next Steps** 
First and foremost, I’d like to make some of these. If you generate a pair of earrings that you like and want to have them made, A) note down the parameters you used and B) [email me](mailto:jacob.joergens@gmail.com) and we can have a cheeky discussion. 

Second, I want to add some features. Off the top, it would be nice to be able to save parameters and download the 3dm file of the output geometry. 

Third, there are still some parts of the model I’d like to optimize to further reduce computational load and wait times. 

Fourth, if there’s decent interest then in the medium term I’d like to make an online storefront for these which would require some work. 

# **How It Works**
Input data is sent to a Grasshopper file which is passed to a Rhino.Compute server hosted on an AWS EC2 instance. The Rhino compute server returns rhino3dm JSON data which is loaded and rendered in the browser using Three.js. There are three categories of input data: 1) parameter values, 2) display values and 3) pdb atom data. Parameter and display values are both set in the graphical user interface. Changes to display values only trigger re-renders in the browser because they only involve Three.js. All other changes trigger calls to the Rhino.Compute Server to run the grasshopper file with updated parameters. When the page loads and all the components mount, the Rhino.Compute server is called with a default protein, in this case an enzyme found to break down PVA plastics. This default PDB data can be changed from the search bar which queries the RCSB Protein Data Bank API. 